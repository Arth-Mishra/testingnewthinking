"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_node-wav_index_js"],{

/***/ "./node_modules/node-wav/index.js":
/*!****************************************!*\
  !*** ./node_modules/node-wav/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n\n\nconst data_decoders = {\n  pcm8: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++] - 128;\n        output[ch][i] = data < 0 ? data / 128 : data / 127;\n      }\n    }\n  },\n  pcm16: (buffer, offset, output, channels, samples) => {\n    let input = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 32768 : data / 32767;\n      }\n    }\n  },\n  pcm24: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let x0 = input[pos++];\n        let x1 = input[pos++];\n        let x2 = input[pos++];\n        let xx = (x0 + (x1 << 8) + (x2 << 16));\n        let data = xx > 0x800000 ? xx - 0x1000000 : xx;\n        output[ch][i] = data < 0 ? data / 8388608 : data / 8388607;\n      }\n    }\n  },\n  pcm32: (buffer, offset, output, channels, samples) => {\n    let input = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 2147483648 : data / 2147483647;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, output, channels, samples) => {\n    let input = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch)\n        output[ch][i] = input[pos++];\n    }\n  },\n  pcm64f: (buffer, offset, output, channels, samples) => {\n    let input = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch)\n        output[ch][i] = input[pos++];\n    }\n  },\n};\n\nconst data_encoders = {\n  pcm8: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v * 0.5 + 0.5) * 255) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm16: (buffer, offset, input, channels, samples) => {\n    let output = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? v * 32768 : v * 32767) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm24: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? 0x1000000 + v * 8388608 : v * 8388607) | 0;\n        output[pos++] = (v >> 0) & 0xff;\n        output[pos++] = (v >> 8) & 0xff;\n        output[pos++] = (v >> 16) & 0xff;\n      }\n    }\n  },\n  pcm32: (buffer, offset, input, channels, samples) => {\n    let output = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? v * 2147483648 : v * 2147483647) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, input, channels, samples) => {\n    let output = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));        \n        output[pos++] = v;\n      }\n    }\n  },\n  pcm64f: (buffer, offset, input, channels, samples) => {\n    let output = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));        \n        output[pos++] = v;\n      }\n    }\n  },\n};\n\nfunction lookup(table, bitDepth, floatingPoint) {\n  let name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\n  let fn = table[name];\n  if (!fn)\n    throw new TypeError('Unsupported data format: ' + name);\n  return fn;\n}\n\nfunction decode(buffer) {\n  let pos = 0, end = 0;\n  if (buffer.buffer) {\n    // If we are handed a typed array or a buffer, then we have to consider the\n    // offset and length into the underlying array buffer.\n    pos = buffer.byteOffset;\n    end = buffer.length;\n    buffer = buffer.buffer;\n  } else {\n    // If we are handed a straight up array buffer, start at offset 0 and use\n    // the full length of the buffer.\n    pos = 0;\n    end = buffer.byteLength;\n  }\n\n  let v = new DataView(buffer);\n\n  function u8() {\n    let x = v.getUint8(pos);\n    pos++;\n    return x;\n  }\n\n  function u16() {\n    let x = v.getUint16(pos, true);\n    pos += 2;\n    return x;\n  }\n\n  function u32() {\n    let x = v.getUint32(pos, true);\n    pos += 4;\n    return x;\n  }\n\n  function string(len) {\n    let str = '';\n    for (let i = 0; i < len; ++i)\n      str += String.fromCharCode(u8());\n    return str;\n  }\n\n  if (string(4) !== 'RIFF')\n    throw new TypeError('Invalid WAV file');\n  u32();\n  if (string(4) !== 'WAVE')\n    throw new TypeError('Invalid WAV file');\n\n  let fmt;\n  \n  while (pos < end) {\n    let type = string(4);\n    let size = u32();\n    let next = pos + size;\n    switch (type) {\n    case 'fmt ':\n      let formatId = u16();\n      if (formatId !== 0x0001 && formatId !== 0x0003)\n        throw new TypeError('Unsupported format in WAV file: ' + formatId.toString(16));\n      fmt = {\n        format: 'lpcm',\n        floatingPoint: formatId === 0x0003,\n        channels: u16(),\n        sampleRate: u32(),\n        byteRate: u32(),\n        blockSize: u16(),\n        bitDepth: u16(),\n      };\n      break;\n    case 'data':\n      if (!fmt)\n        throw new TypeError('Missing \"fmt \" chunk.');\n      let samples = Math.floor(size / fmt.blockSize);\n      let channels = fmt.channels;\n      let sampleRate = fmt.sampleRate;\n      let channelData = [];\n      for (let ch = 0; ch < channels; ++ch)\n        channelData[ch] = new Float32Array(samples);\n      lookup(data_decoders, fmt.bitDepth, fmt.floatingPoint)(buffer, pos, channelData, channels, samples);\n      return {\n        sampleRate: sampleRate,\n        channelData: channelData\n      };\n      break;\n    }\n    pos = next;\n  }\n}\n\nfunction encode(channelData, opts) {\n  let sampleRate = opts.sampleRate || 16000;\n  let floatingPoint = !!(opts.float || opts.floatingPoint);\n  let bitDepth = floatingPoint ? 32 : ((opts.bitDepth | 0) || 16);\n  let channels = channelData.length;\n  let samples = channelData[0].length;\n  let buffer = new ArrayBuffer(44 + (samples * channels * (bitDepth >> 3)));\n\n  let v = new DataView(buffer);\n  let pos = 0;\n\n  function u8(x) {\n    v.setUint8(pos++, x);\n  }\n\n  function u16(x) {\n    v.setUint16(pos, x, true);\n    pos += 2;\n  }\n\n  function u32(x) {\n    v.setUint32(pos, x, true);\n    pos += 4;\n  }\n  \n  function string(s) {\n    for (var i = 0; i < s.length; ++i)\n      u8(s.charCodeAt(i));\n  }\n\n  // write header\n  string('RIFF');\n  u32(buffer.byteLength - 8);\n  string('WAVE');\n\n  // write 'fmt ' chunk\n  string('fmt ');\n  u32(16);\n  u16(floatingPoint ? 0x0003 : 0x0001);\n  u16(channels);\n  u32(sampleRate);\n  u32(sampleRate * channels * (bitDepth >> 3));\n  u16(channels * (bitDepth >> 3));\n  u16(bitDepth);\n\n  // write 'data' chunk\n  string('data');\n  u32(buffer.byteLength - 44);\n  lookup(data_encoders, bitDepth, floatingPoint)(buffer, pos, channelData, channels, samples);\n\n  return Buffer(buffer);\n}\n\nmodule.exports = {\n  decode: decode,\n  encode: encode,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxNQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25vZGUtd2F2L2luZGV4LmpzPzM3MDciXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkYXRhX2RlY29kZXJzID0ge1xuICBwY204OiAoYnVmZmVyLCBvZmZzZXQsIG91dHB1dCwgY2hhbm5lbHMsIHNhbXBsZXMpID0+IHtcbiAgICBsZXQgaW5wdXQgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgZGF0YSA9IGlucHV0W3BvcysrXSAtIDEyODtcbiAgICAgICAgb3V0cHV0W2NoXVtpXSA9IGRhdGEgPCAwID8gZGF0YSAvIDEyOCA6IGRhdGEgLyAxMjc7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwY20xNjogKGJ1ZmZlciwgb2Zmc2V0LCBvdXRwdXQsIGNoYW5uZWxzLCBzYW1wbGVzKSA9PiB7XG4gICAgbGV0IGlucHV0ID0gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlczsgKytpKSB7XG4gICAgICBmb3IgKGxldCBjaCA9IDA7IGNoIDwgY2hhbm5lbHM7ICsrY2gpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBpbnB1dFtwb3MrK107XG4gICAgICAgIG91dHB1dFtjaF1baV0gPSBkYXRhIDwgMCA/IGRhdGEgLyAzMjc2OCA6IGRhdGEgLyAzMjc2NztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBjbTI0OiAoYnVmZmVyLCBvZmZzZXQsIG91dHB1dCwgY2hhbm5lbHMsIHNhbXBsZXMpID0+IHtcbiAgICBsZXQgaW5wdXQgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgeDAgPSBpbnB1dFtwb3MrK107XG4gICAgICAgIGxldCB4MSA9IGlucHV0W3BvcysrXTtcbiAgICAgICAgbGV0IHgyID0gaW5wdXRbcG9zKytdO1xuICAgICAgICBsZXQgeHggPSAoeDAgKyAoeDEgPDwgOCkgKyAoeDIgPDwgMTYpKTtcbiAgICAgICAgbGV0IGRhdGEgPSB4eCA+IDB4ODAwMDAwID8geHggLSAweDEwMDAwMDAgOiB4eDtcbiAgICAgICAgb3V0cHV0W2NoXVtpXSA9IGRhdGEgPCAwID8gZGF0YSAvIDgzODg2MDggOiBkYXRhIC8gODM4ODYwNztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBjbTMyOiAoYnVmZmVyLCBvZmZzZXQsIG91dHB1dCwgY2hhbm5lbHMsIHNhbXBsZXMpID0+IHtcbiAgICBsZXQgaW5wdXQgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgZGF0YSA9IGlucHV0W3BvcysrXTtcbiAgICAgICAgb3V0cHV0W2NoXVtpXSA9IGRhdGEgPCAwID8gZGF0YSAvIDIxNDc0ODM2NDggOiBkYXRhIC8gMjE0NzQ4MzY0NztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBjbTMyZjogKGJ1ZmZlciwgb2Zmc2V0LCBvdXRwdXQsIGNoYW5uZWxzLCBzYW1wbGVzKSA9PiB7XG4gICAgbGV0IGlucHV0ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaClcbiAgICAgICAgb3V0cHV0W2NoXVtpXSA9IGlucHV0W3BvcysrXTtcbiAgICB9XG4gIH0sXG4gIHBjbTY0ZjogKGJ1ZmZlciwgb2Zmc2V0LCBvdXRwdXQsIGNoYW5uZWxzLCBzYW1wbGVzKSA9PiB7XG4gICAgbGV0IGlucHV0ID0gbmV3IEZsb2F0NjRBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaClcbiAgICAgICAgb3V0cHV0W2NoXVtpXSA9IGlucHV0W3BvcysrXTtcbiAgICB9XG4gIH0sXG59O1xuXG5jb25zdCBkYXRhX2VuY29kZXJzID0ge1xuICBwY204OiAoYnVmZmVyLCBvZmZzZXQsIGlucHV0LCBjaGFubmVscywgc2FtcGxlcykgPT4ge1xuICAgIGxldCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgdiA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbihpbnB1dFtjaF1baV0sIDEpKTtcbiAgICAgICAgdiA9ICgodiAqIDAuNSArIDAuNSkgKiAyNTUpIHwgMDtcbiAgICAgICAgb3V0cHV0W3BvcysrXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwY20xNjogKGJ1ZmZlciwgb2Zmc2V0LCBpbnB1dCwgY2hhbm5lbHMsIHNhbXBsZXMpID0+IHtcbiAgICBsZXQgb3V0cHV0ID0gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlczsgKytpKSB7XG4gICAgICBmb3IgKGxldCBjaCA9IDA7IGNoIDwgY2hhbm5lbHM7ICsrY2gpIHtcbiAgICAgICAgbGV0IHYgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oaW5wdXRbY2hdW2ldLCAxKSk7XG4gICAgICAgIHYgPSAoKHYgPCAwKSA/IHYgKiAzMjc2OCA6IHYgKiAzMjc2NykgfCAwO1xuICAgICAgICBvdXRwdXRbcG9zKytdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBjbTI0OiAoYnVmZmVyLCBvZmZzZXQsIGlucHV0LCBjaGFubmVscywgc2FtcGxlcykgPT4ge1xuICAgIGxldCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgdiA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbihpbnB1dFtjaF1baV0sIDEpKTtcbiAgICAgICAgdiA9ICgodiA8IDApID8gMHgxMDAwMDAwICsgdiAqIDgzODg2MDggOiB2ICogODM4ODYwNykgfCAwO1xuICAgICAgICBvdXRwdXRbcG9zKytdID0gKHYgPj4gMCkgJiAweGZmO1xuICAgICAgICBvdXRwdXRbcG9zKytdID0gKHYgPj4gOCkgJiAweGZmO1xuICAgICAgICBvdXRwdXRbcG9zKytdID0gKHYgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBjbTMyOiAoYnVmZmVyLCBvZmZzZXQsIGlucHV0LCBjaGFubmVscywgc2FtcGxlcykgPT4ge1xuICAgIGxldCBvdXRwdXQgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgdiA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbihpbnB1dFtjaF1baV0sIDEpKTtcbiAgICAgICAgdiA9ICgodiA8IDApID8gdiAqIDIxNDc0ODM2NDggOiB2ICogMjE0NzQ4MzY0NykgfCAwO1xuICAgICAgICBvdXRwdXRbcG9zKytdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBjbTMyZjogKGJ1ZmZlciwgb2Zmc2V0LCBpbnB1dCwgY2hhbm5lbHMsIHNhbXBsZXMpID0+IHtcbiAgICBsZXQgb3V0cHV0ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgdiA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbihpbnB1dFtjaF1baV0sIDEpKTsgICAgICAgIFxuICAgICAgICBvdXRwdXRbcG9zKytdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBjbTY0ZjogKGJ1ZmZlciwgb2Zmc2V0LCBpbnB1dCwgY2hhbm5lbHMsIHNhbXBsZXMpID0+IHtcbiAgICBsZXQgb3V0cHV0ID0gbmV3IEZsb2F0NjRBcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaCkge1xuICAgICAgICBsZXQgdiA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbihpbnB1dFtjaF1baV0sIDEpKTsgICAgICAgIFxuICAgICAgICBvdXRwdXRbcG9zKytdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBsb29rdXAodGFibGUsIGJpdERlcHRoLCBmbG9hdGluZ1BvaW50KSB7XG4gIGxldCBuYW1lID0gJ3BjbScgKyBiaXREZXB0aCArIChmbG9hdGluZ1BvaW50ID8gJ2YnIDogJycpO1xuICBsZXQgZm4gPSB0YWJsZVtuYW1lXTtcbiAgaWYgKCFmbilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIGZvcm1hdDogJyArIG5hbWUpO1xuICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgbGV0IHBvcyA9IDAsIGVuZCA9IDA7XG4gIGlmIChidWZmZXIuYnVmZmVyKSB7XG4gICAgLy8gSWYgd2UgYXJlIGhhbmRlZCBhIHR5cGVkIGFycmF5IG9yIGEgYnVmZmVyLCB0aGVuIHdlIGhhdmUgdG8gY29uc2lkZXIgdGhlXG4gICAgLy8gb2Zmc2V0IGFuZCBsZW5ndGggaW50byB0aGUgdW5kZXJseWluZyBhcnJheSBidWZmZXIuXG4gICAgcG9zID0gYnVmZmVyLmJ5dGVPZmZzZXQ7XG4gICAgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgICBidWZmZXIgPSBidWZmZXIuYnVmZmVyO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGFyZSBoYW5kZWQgYSBzdHJhaWdodCB1cCBhcnJheSBidWZmZXIsIHN0YXJ0IGF0IG9mZnNldCAwIGFuZCB1c2VcbiAgICAvLyB0aGUgZnVsbCBsZW5ndGggb2YgdGhlIGJ1ZmZlci5cbiAgICBwb3MgPSAwO1xuICAgIGVuZCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgbGV0IHYgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblxuICBmdW5jdGlvbiB1OCgpIHtcbiAgICBsZXQgeCA9IHYuZ2V0VWludDgocG9zKTtcbiAgICBwb3MrKztcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHUxNigpIHtcbiAgICBsZXQgeCA9IHYuZ2V0VWludDE2KHBvcywgdHJ1ZSk7XG4gICAgcG9zICs9IDI7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiB1MzIoKSB7XG4gICAgbGV0IHggPSB2LmdldFVpbnQzMihwb3MsIHRydWUpO1xuICAgIHBvcyArPSA0O1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nKGxlbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTgoKSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmIChzdHJpbmcoNCkgIT09ICdSSUZGJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFdBViBmaWxlJyk7XG4gIHUzMigpO1xuICBpZiAoc3RyaW5nKDQpICE9PSAnV0FWRScpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBXQVYgZmlsZScpO1xuXG4gIGxldCBmbXQ7XG4gIFxuICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgbGV0IHR5cGUgPSBzdHJpbmcoNCk7XG4gICAgbGV0IHNpemUgPSB1MzIoKTtcbiAgICBsZXQgbmV4dCA9IHBvcyArIHNpemU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZm10ICc6XG4gICAgICBsZXQgZm9ybWF0SWQgPSB1MTYoKTtcbiAgICAgIGlmIChmb3JtYXRJZCAhPT0gMHgwMDAxICYmIGZvcm1hdElkICE9PSAweDAwMDMpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIGZvcm1hdCBpbiBXQVYgZmlsZTogJyArIGZvcm1hdElkLnRvU3RyaW5nKDE2KSk7XG4gICAgICBmbXQgPSB7XG4gICAgICAgIGZvcm1hdDogJ2xwY20nLFxuICAgICAgICBmbG9hdGluZ1BvaW50OiBmb3JtYXRJZCA9PT0gMHgwMDAzLFxuICAgICAgICBjaGFubmVsczogdTE2KCksXG4gICAgICAgIHNhbXBsZVJhdGU6IHUzMigpLFxuICAgICAgICBieXRlUmF0ZTogdTMyKCksXG4gICAgICAgIGJsb2NrU2l6ZTogdTE2KCksXG4gICAgICAgIGJpdERlcHRoOiB1MTYoKSxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkYXRhJzpcbiAgICAgIGlmICghZm10KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIFwiZm10IFwiIGNodW5rLicpO1xuICAgICAgbGV0IHNhbXBsZXMgPSBNYXRoLmZsb29yKHNpemUgLyBmbXQuYmxvY2tTaXplKTtcbiAgICAgIGxldCBjaGFubmVscyA9IGZtdC5jaGFubmVscztcbiAgICAgIGxldCBzYW1wbGVSYXRlID0gZm10LnNhbXBsZVJhdGU7XG4gICAgICBsZXQgY2hhbm5lbERhdGEgPSBbXTtcbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBjaGFubmVsczsgKytjaClcbiAgICAgICAgY2hhbm5lbERhdGFbY2hdID0gbmV3IEZsb2F0MzJBcnJheShzYW1wbGVzKTtcbiAgICAgIGxvb2t1cChkYXRhX2RlY29kZXJzLCBmbXQuYml0RGVwdGgsIGZtdC5mbG9hdGluZ1BvaW50KShidWZmZXIsIHBvcywgY2hhbm5lbERhdGEsIGNoYW5uZWxzLCBzYW1wbGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUsXG4gICAgICAgIGNoYW5uZWxEYXRhOiBjaGFubmVsRGF0YVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwb3MgPSBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kZShjaGFubmVsRGF0YSwgb3B0cykge1xuICBsZXQgc2FtcGxlUmF0ZSA9IG9wdHMuc2FtcGxlUmF0ZSB8fCAxNjAwMDtcbiAgbGV0IGZsb2F0aW5nUG9pbnQgPSAhIShvcHRzLmZsb2F0IHx8IG9wdHMuZmxvYXRpbmdQb2ludCk7XG4gIGxldCBiaXREZXB0aCA9IGZsb2F0aW5nUG9pbnQgPyAzMiA6ICgob3B0cy5iaXREZXB0aCB8IDApIHx8IDE2KTtcbiAgbGV0IGNoYW5uZWxzID0gY2hhbm5lbERhdGEubGVuZ3RoO1xuICBsZXQgc2FtcGxlcyA9IGNoYW5uZWxEYXRhWzBdLmxlbmd0aDtcbiAgbGV0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0NCArIChzYW1wbGVzICogY2hhbm5lbHMgKiAoYml0RGVwdGggPj4gMykpKTtcblxuICBsZXQgdiA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICBsZXQgcG9zID0gMDtcblxuICBmdW5jdGlvbiB1OCh4KSB7XG4gICAgdi5zZXRVaW50OChwb3MrKywgeCk7XG4gIH1cblxuICBmdW5jdGlvbiB1MTYoeCkge1xuICAgIHYuc2V0VWludDE2KHBvcywgeCwgdHJ1ZSk7XG4gICAgcG9zICs9IDI7XG4gIH1cblxuICBmdW5jdGlvbiB1MzIoeCkge1xuICAgIHYuc2V0VWludDMyKHBvcywgeCwgdHJ1ZSk7XG4gICAgcG9zICs9IDQ7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHN0cmluZyhzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKVxuICAgICAgdTgocy5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIC8vIHdyaXRlIGhlYWRlclxuICBzdHJpbmcoJ1JJRkYnKTtcbiAgdTMyKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gOCk7XG4gIHN0cmluZygnV0FWRScpO1xuXG4gIC8vIHdyaXRlICdmbXQgJyBjaHVua1xuICBzdHJpbmcoJ2ZtdCAnKTtcbiAgdTMyKDE2KTtcbiAgdTE2KGZsb2F0aW5nUG9pbnQgPyAweDAwMDMgOiAweDAwMDEpO1xuICB1MTYoY2hhbm5lbHMpO1xuICB1MzIoc2FtcGxlUmF0ZSk7XG4gIHUzMihzYW1wbGVSYXRlICogY2hhbm5lbHMgKiAoYml0RGVwdGggPj4gMykpO1xuICB1MTYoY2hhbm5lbHMgKiAoYml0RGVwdGggPj4gMykpO1xuICB1MTYoYml0RGVwdGgpO1xuXG4gIC8vIHdyaXRlICdkYXRhJyBjaHVua1xuICBzdHJpbmcoJ2RhdGEnKTtcbiAgdTMyKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gNDQpO1xuICBsb29rdXAoZGF0YV9lbmNvZGVycywgYml0RGVwdGgsIGZsb2F0aW5nUG9pbnQpKGJ1ZmZlciwgcG9zLCBjaGFubmVsRGF0YSwgY2hhbm5lbHMsIHNhbXBsZXMpO1xuXG4gIHJldHVybiBCdWZmZXIoYnVmZmVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGU6IGVuY29kZSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/node-wav/index.js\n"));

/***/ })

}]);